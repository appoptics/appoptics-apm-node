#
# supporting backends for node-appoptics testing
#
version: '2.4'

services:
#  main:
#    container_name: main
#    image: main
#    build:
#      context: test/docker
#      dockerfile: main.yml
#      args:
#        # if AO_TEST_PACKAGE and AO_TEST_GITAUTH are not set then the
#        # bindings installation will attempt to download the HEAD of the
#        # master branch from the public repository.
#        #
#        # expect librato/node-appoptics-bindings#new-liboboe while private
#        - AO_TEST_PACKAGE
#        # expect a git auth token (or extend Dockerfile with user and password)
#        - AO_TEST_GITAUTH
#        # - AO_TEST_GITUSER
#        # - AO_TEST_GITPASS
#        # - AO_TEST_COLLECTOR_CERT=${AO_COLLECTOR_CERT:-test/certs/scribe-collector.crt}
#        - AO_TEST_COLLECTOR_CERT=${AO_COLLECTOR_CERT:-test/certs/java-collector.crt}
#        # - AO_TEST_COLLECTOR=${AO_COLLECTOR:-scribe-collector:4444}
#        - AO_TEST_COLLECTOR=${AO_COLLECTOR:-java-collector:12222}
#        # the next two set liboboe to send to the mock collector
#        # for testing. these should be set to run the test suite.
#        - AO_TEST_REPORTER=udp
#        - AO_TEST_REPORTER_UDP=localhost:7832
#    volumes:
#      # map the directory this file is in to the /appoptics/ directory
#      - "${PWD}:/appoptics/"
##    volumes:
##      - type: volume
#    logging:
#      options:
#        max-file: "1"
#        max-size: 50m
#    #
#    # wait for the dependencies. (this container doesn't really do anything unless
#    # running the tests in this context. in that case it is easy enough to invoke
#    # env.sh manually as that is the way the tests are run.)
#    #
#    depends_on:
#      - wait
#    links:
#      - wait

  #----------------------------------------------------------------------------
  # test collector - instrumented test apps report to this instead of the real
  # backend. in addition to not flooding the backend with data, this allows us
  # to control the sampling and limiting settings sent down to agents during
  # the benchmark. java-collector default config:
  # https://github.com/librato/apm-agent-test-collector/blob/master/config.json
  #----------------------------------------------------------------------------
  java-collector-1:
    image: 'traceqa/test-collector:java-collector'
    mem_limit: 1G
    cpus: 1.0
    volumes:
      - ./test/java-collector/config.json:/config.json
      - ./test/java-collector/settings.db.high-throughput:/settings.db
    #environment:
    #  - "JAVA_OPTS=-Dlog4j.configuration=log4j-debug.properties"
    logging:
      options:
        max-file: '1'
        max-size: 100m
    ports:
      - '8181:8181'
      - '12222:12222'

  #
  # second java-collector for benchmarking purposes if
  # needed.
  #
  #java-collector-2:
  #  image: 'traceqa/test-collector:java-collector'
  #  mem_limit: 1G
  #  cpus: 1.0
  #  volumes:
  #    - ./test/java-collector/config.json:/config.json
  #    - ./test/java-collector/settings.db.high-throughput:/settings.db
  #  #environment:
  #  #  - "JAVA_OPTS=-Dlog4j.configuration=log4j-debug.properties"
  #  logging:
  #    options:
  #      max-file: '1'
  #      max-size: 100m
  #  ports:
  #    - '8182:8181'
  #    - '12223:12222'




  #
  # Containers required for testing supported probes. Each
  # depends on a dockerfile in test/docker/ that specifies
  # the correct image.
  #
  cassandra:
    image: "cassandra"
    build:
      context: test/docker/
      dockerfile: cassandra.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      # host:container
      - "9042:9042"

  memcached:
    image: "memcached"
    build:
      context: test/docker/
      dockerfile: memcached.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "11211:11211"


  mongo_2_4:
    image: "mongo_2_4"
    build:
      context: test/docker/
      dockerfile: mongo_2_4.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      # host:container
      - "27016:27017"

  mongo_2_6:
    image: "mongo_2_6"
    build:
      context: test/docker/
      dockerfile: mongo_2_6.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "${AO_TEST_MONGO_2_6_HOST_PORT:-27017}:27017"

  mongo_3_0:
    image: "mongo_3_0"
    build:
      context: test/docker/
      dockerfile: mongo_3_0.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "27018:27017"

  mongo_replset:
    image: "traceqa/mongo-set"
    build:
      context: test/docker/
      dockerfile: mongo_replset.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "30001:30001"
      - "30002:30002"
      - "30003:30003"
    environment:
      - "REPLSETMEMBERS=3"
      - "REPLSETHOST=localhost"

  mysql:
    #container_name: mysql
    image: "mysql:5.7.13"
    ports:
      - "${AO_TEST_MYSQL_HOST_PORT:-3306}:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=admin

  mssql:
    image: "mssql"
    build:
      context: test/docker/
      dockerfile: mssql.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "1433:1433"

  oracle:
    image: "oracle"
    build:
      context: test/docker/
      dockerfile: oracle.yml
    build:
      context: test/docker/
      dockerfile: oracle.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "1521:1521"

  postgres:
    image: "postgres"
    build:
      context: test/docker/
      dockerfile: postgres.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "5432:5432"
    environment:
      # sets password to this so make pg.test.js agree
      - POSTGRES_PASSWORD=xyzzy

  rabbitmq:
    image: "rabbitmq"
    build:
      context: test/docker/
      dockerfile: rabbitmq.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "5672:5672"

  redis:
    image: "redis"
    build:
      context: test/docker/
      dockerfile: redis.yml
    logging:
      options:
        max-file: "1"
        max-size: 50m
    ports:
      - "6379:6379"

#  wait:
#    container_name: wait
#    image: waisbrot/wait
#    depends_on:
#      - cassandra
#      - memcached
#      - mongo_2_4
#      - mongo_2_6
#      - mongo_3_0
#      - mssql
#      - mysql
#      - postgres
#      - rabbitmq
#      - redis
#    links:
#      - cassandra
#      - memcached
#      - mongo_2_4
#      - mongo_2_6
#      - mongo_3_0
#      - mssql
#      - mysql
#      - postgres
#      - rabbitmq
#      - redis
#    environment:
#      - TARGETS=cassandra:9042;memcached:11211;mongo:27017;mssql:1433;mysql:3306;postgres:5432;rabbitmq:5672;redis:6379
#
